create schema if not exists "business_information";


drop policy "Allow public read-only access." on "public"."prices";

drop policy "Allow public read-only access." on "public"."products";

drop policy "Can only view own subs data." on "public"."subscriptions";

drop policy "Can update own user data." on "public"."users";

drop policy "Can view own user data." on "public"."users";

alter table "public"."customers" drop constraint "customers_id_fkey";

alter table "public"."prices" drop constraint "prices_currency_check";

alter table "public"."subscriptions" drop constraint "subscriptions_user_id_fkey";

alter table "public"."users" drop constraint "users_id_fkey";


/**
* This trigger automatically creates a user entry when a new user signs up via Supabase Auth.
*/ 
create function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.users (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

create table "public"."business_information" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid default auth.uid(),
    "domain" text,
    "rankings_data" jsonb,
    "rankings_updated_at" timestamp with time zone
);


alter table "public"."business_information" enable row level security;

create table "public"."competitors" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid default auth.uid(),
    "domain" text,
    "rankings_data" jsonb,
    "rankings_updated_at" timestamp with time zone
);


alter table "public"."competitors" enable row level security;

create table "public"."seo_crawls" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid default auth.uid(),
    "external_job_id" character varying,
    "domain" text,
    "onpage_score" text,
    "total_pages" text,
    "page_metrics" jsonb,
    "crawl_status" jsonb,
    "lighthouse_task_id" text,
    "lighthouse_data" jsonb,
    "scraped_pages" jsonb
);


alter table "public"."seo_crawls" enable row level security;

alter table "public"."customers" add column "created_at" timestamp with time zone not null default now();

alter table "public"."customers" add column "referral_code" text;

alter table "public"."customers" alter column "id" set default auth.uid();

alter table "public"."prices" alter column "interval" set data type text using "interval"::text;

alter table "public"."prices" alter column "interval_count" set data type smallint using "interval_count"::smallint;

alter table "public"."prices" alter column "trial_period_days" set data type smallint using "trial_period_days"::smallint;

alter table "public"."prices" alter column "type" set data type text using "type"::text;

alter table "public"."products" alter column "active" set not null;

alter table "public"."subscriptions" add column "created_at" timestamp with time zone not null default now();

alter table "public"."subscriptions" alter column "cancel_at" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "cancel_at" set data type timestamp without time zone using "cancel_at"::timestamp without time zone;

alter table "public"."subscriptions" alter column "canceled_at" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "canceled_at" set data type timestamp without time zone using "canceled_at"::timestamp without time zone;

alter table "public"."subscriptions" alter column "created" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "created" set data type timestamp without time zone using "created"::timestamp without time zone;

alter table "public"."subscriptions" alter column "current_period_end" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "current_period_end" set data type timestamp without time zone using "current_period_end"::timestamp without time zone;

alter table "public"."subscriptions" alter column "current_period_start" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "current_period_start" set data type timestamp without time zone using "current_period_start"::timestamp without time zone;

alter table "public"."subscriptions" alter column "ended_at" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "ended_at" set data type timestamp without time zone using "ended_at"::timestamp without time zone;

alter table "public"."subscriptions" alter column "quantity" set data type smallint using "quantity"::smallint;

alter table "public"."subscriptions" alter column "status" set data type text using "status"::text;

alter table "public"."subscriptions" alter column "trial_end" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "trial_end" set data type timestamp without time zone using "trial_end"::timestamp without time zone;

alter table "public"."subscriptions" alter column "trial_start" set default (now() AT TIME ZONE 'utc'::text);

alter table "public"."subscriptions" alter column "trial_start" set data type timestamp without time zone using "trial_start"::timestamp without time zone;

alter table "public"."subscriptions" alter column "user_id" set default auth.uid();

alter table "public"."subscriptions" alter column "user_id" drop not null;

alter table "public"."users" add column "created_at" timestamp with time zone not null default now();

alter table "public"."users" alter column "id" set default auth.uid();

drop type "public"."pricing_plan_interval";

drop type "public"."pricing_type";

drop type "public"."subscription_status";

CREATE UNIQUE INDEX business_information_pkey ON public.business_information USING btree (id);

CREATE UNIQUE INDEX competitors_pkey ON public.competitors USING btree (id);

CREATE UNIQUE INDEX seo_crawls_pkey ON public.seo_crawls USING btree (id);

CREATE UNIQUE INDEX users_user_id_key ON public.customers USING btree (id);

alter table "public"."business_information" add constraint "business_information_pkey" PRIMARY KEY using index "business_information_pkey";

alter table "public"."competitors" add constraint "competitors_pkey" PRIMARY KEY using index "competitors_pkey";

alter table "public"."seo_crawls" add constraint "seo_crawls_pkey" PRIMARY KEY using index "seo_crawls_pkey";

alter table "public"."customers" add constraint "users_user_id_key" UNIQUE using index "users_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.ufn_get_user_migration_data_json()
 RETURNS TABLE(j json)
 LANGUAGE plpgsql
AS $function$
BEGIN
RETURN QUERY
SELECT array_to_json(array_agg(json_strip_nulls(row_to_json(r))))
FROM
    (SELECT
         u.instance_id,
         u.encrypted_password,
         EXTRACT(EPOCH from u.created_at)*1000 as created_at,
         i.provider,
         i.email,
         CASE WHEN u.encrypted_password = '' THEN i.provider||'|'||i.user_id
              ELSE 'auth0'||'|'||i.user_id
             END as "user_id",
         CASE WHEN u.encrypted_password = '' THEN null
              ELSE substring(u.encrypted_password,5,2)
             END as "factor",
         substring(u.encrypted_password,8,22) as salt,
         CASE WHEN u.encrypted_password = '' THEN 'hasprovider'
              ELSE substring(u.encrypted_password,30,31)
             END as "password",
         CASE WHEN u.encrypted_password = '' THEN null
              ELSE 'bcrypt'
             END as "encryptionScheme",
         true as email_verified
     FROM auth.users u JOIN auth.identities i
                            ON u.id = i.user_id
    ) r;
END;
$function$
;

grant delete on table "public"."business_information" to "anon";

grant insert on table "public"."business_information" to "anon";

grant references on table "public"."business_information" to "anon";

grant select on table "public"."business_information" to "anon";

grant trigger on table "public"."business_information" to "anon";

grant truncate on table "public"."business_information" to "anon";

grant update on table "public"."business_information" to "anon";

grant delete on table "public"."business_information" to "authenticated";

grant insert on table "public"."business_information" to "authenticated";

grant references on table "public"."business_information" to "authenticated";

grant select on table "public"."business_information" to "authenticated";

grant trigger on table "public"."business_information" to "authenticated";

grant truncate on table "public"."business_information" to "authenticated";

grant update on table "public"."business_information" to "authenticated";

grant delete on table "public"."business_information" to "service_role";

grant insert on table "public"."business_information" to "service_role";

grant references on table "public"."business_information" to "service_role";

grant select on table "public"."business_information" to "service_role";

grant trigger on table "public"."business_information" to "service_role";

grant truncate on table "public"."business_information" to "service_role";

grant update on table "public"."business_information" to "service_role";

grant delete on table "public"."competitors" to "anon";

grant insert on table "public"."competitors" to "anon";

grant references on table "public"."competitors" to "anon";

grant select on table "public"."competitors" to "anon";

grant trigger on table "public"."competitors" to "anon";

grant truncate on table "public"."competitors" to "anon";

grant update on table "public"."competitors" to "anon";

grant delete on table "public"."competitors" to "authenticated";

grant insert on table "public"."competitors" to "authenticated";

grant references on table "public"."competitors" to "authenticated";

grant select on table "public"."competitors" to "authenticated";

grant trigger on table "public"."competitors" to "authenticated";

grant truncate on table "public"."competitors" to "authenticated";

grant update on table "public"."competitors" to "authenticated";

grant delete on table "public"."competitors" to "service_role";

grant insert on table "public"."competitors" to "service_role";

grant references on table "public"."competitors" to "service_role";

grant select on table "public"."competitors" to "service_role";

grant trigger on table "public"."competitors" to "service_role";

grant truncate on table "public"."competitors" to "service_role";

grant update on table "public"."competitors" to "service_role";

grant delete on table "public"."seo_crawls" to "anon";

grant insert on table "public"."seo_crawls" to "anon";

grant references on table "public"."seo_crawls" to "anon";

grant select on table "public"."seo_crawls" to "anon";

grant trigger on table "public"."seo_crawls" to "anon";

grant truncate on table "public"."seo_crawls" to "anon";

grant update on table "public"."seo_crawls" to "anon";

grant delete on table "public"."seo_crawls" to "authenticated";

grant insert on table "public"."seo_crawls" to "authenticated";

grant references on table "public"."seo_crawls" to "authenticated";

grant select on table "public"."seo_crawls" to "authenticated";

grant trigger on table "public"."seo_crawls" to "authenticated";

grant truncate on table "public"."seo_crawls" to "authenticated";

grant update on table "public"."seo_crawls" to "authenticated";

grant delete on table "public"."seo_crawls" to "service_role";

grant insert on table "public"."seo_crawls" to "service_role";

grant references on table "public"."seo_crawls" to "service_role";

grant select on table "public"."seo_crawls" to "service_role";

grant trigger on table "public"."seo_crawls" to "service_role";

grant truncate on table "public"."seo_crawls" to "service_role";

grant update on table "public"."seo_crawls" to "service_role";

create policy "Enable insert for users based on user_id"
on "public"."business_information"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Read for users based on user_id"
on "public"."business_information"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."competitors"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable read access for all users"
on "public"."competitors"
as permissive
for select
to service_role, authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."customers"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Enable read access for all users"
on "public"."customers"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."prices"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."products"
as permissive
for select
to public
using (true);


create policy "Enable read access for service role"
on "public"."products"
as permissive
for select
to service_role
using (true);


create policy "Insert for SEO Crawls"
on "public"."seo_crawls"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Read Access for SEO Crawls"
on "public"."seo_crawls"
as permissive
for select
to service_role
using (true);


create policy "SEO Crawls read for website"
on "public"."seo_crawls"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."subscriptions"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Enable insert for authenticated users only"
on "public"."users"
as permissive
for insert
to authenticated
with check ((auth.uid() = id));


create policy "Enable read access for all users"
on "public"."users"
as permissive
for select
to public
using ((auth.uid() = id));


CREATE TRIGGER "Create Stripe Customer" AFTER INSERT ON public.customers FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://aryklmppwuliidmvzwpo.supabase.co/functions/v1/create-stripe-customer', 'POST', '{"Content-type":"application/json","Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFyeWtsbXBwd3VsaWlkbXZ6d3BvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcyNTIyNTMzNSwiZXhwIjoyMDQwODAxMzM1fQ.vJuoCasJnJDE8A1AP0Vt6x68bCKIjXpoWYNTymlM6S0"}', '{}', '1000');


